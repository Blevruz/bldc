
/*
	This file is part of the VESC firmware.

	The VESC firmware is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The VESC firmware is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
/*	PDS (Power Drive System) Objects
 *	Place implementation of CiA 402 objects here
 *	TODO: make a TODO list
 */


#include "co_core.h"
#include "mc_interface.h"

//TODO: move RPM to here

/*	CONTROL WORD: See CiA 402 part 2 section 8.4.1
 *		Structure:
 *	Bit 0: 		so	switch on
 *	Bit 1:		ev	enable voltage
 *	Bit 2:		qs	quick stop
 *	Bit 3:		eo	enable operation
 *	Bit 4 - 6:	oms	operation mode specific
 *	Bit 7:		fr	fault reset
 *	Bit 8:		h	halt
 *	Bit 9:		oms	operation mode specific
 *	Bit 10:		r	reserved
 *	Bit 11 - 16:	ms	manufacturer specific
 *	
 *	See Table 27 from CiA 402 for behaviours depending on value.
 *	NOTE: would be greatly facilitated by a CiA 402-compliant Finite State Automaton
 */
uint32_t CONTROL_WORD_Size(CO_OBJ *obj, CO_NODE *node, uint32_t width) {
	(void)obj; (void)node; (void)width;
	return 2;	// control word is 2 bytes
}

#define CONTROL_WORD_COMMAND_MASK	0x8F	//keeps only the bits used in Table 27
#define CONTROL_WORD_SHUTDOWN		0x0B	//bit 3 is X
#define CONTROL_WORD_SWITCH_ON		0x07
#define CONTROL_WORD_SO_EN		0x0F	//switch on + enable operation
#define CONTROl_WORD_DISABLE_VOLTAGE_N	0x02	//this command is chosen if input&this == 0
#define CONTROL_WORD_QUICK_STOP_N	0x0A	

#define CONTROL_WORD_FAULT_RESET	0x80	//note: must be rising edge

CO_ERR	CONTROL_WORD_Write (CO_OBJ *obj, CO_NODE *node, void *buffer, uint32_t size) {
	static int fault_reset_up = 0;
	uint16_t controlword = *(uint16_t*)buffer;
	uint16_t command = controlword & CONTROL_WORD_COMMAND_MASK;

	if (command & CONTROL_WORD_FAULT_RESET) {
		if (fault_reset_up) {
			return CO_ERR_NONE;
		}
		fault_reset_up = 1;
		//TODO: actually reset faults
		return CO_ERR_NONE;
	}
	fault_reset_up = 0;
	if (command & CONTROL_WORD_DISABLE_VOLTAGE == 0) {
		//TODO: disable voltage
		return CO_ERR_NONE;
	}

}

CO_OBJ_TYPE COT_CONTROL_WORD = {
	CONTROL_WORD_Size,
	0,
	0,
	CONTROL_WORD_Write
};

